/*本脚本实现了物体贴图检测。用法：在脚本编辑器中运行此脚本即可。华强数码电影技术部  黄喜锋最后由骆立思编辑于2012.3.31Copyleft (c) 2012 Lisi Luo. Life is wonderful, have fun together^_^*/// find all texture nodesglobal proc string[] fh_getTextureNodes() {  string $allTextureNodes[];  string $mayaTextures[] = `ls -type "file" -type "psdFileTex"`;  string $mentalrayTextures[] = fh_getMentalrayTextureNodes();  return $allTextureNodes = stringArrayCatenate ($mayaTextures, $mentalrayTextures);}// find mentalray texture nodesglobal proc string[] fh_getMentalrayTextureNodes() {  string $mentalrayTextures[];  if (`pluginInfo -q -loaded Mayatomr` == 0) {    loadPlugin "Mayatomr";  }  $mentalrayTextures = `ls -type "mentalrayTexture" -type "mentalrayIblShape"`;  return $mentalrayTextures;}// get the texture file path of a texture nodeproc string getTextureFullPath(string $texNode) {  string $fullPath;  int $fileReadable;  if (`nodeType $texNode` == "mentalrayIblShape") {    $fullPath = `getAttr ($texNode + ".texture")`;  } else {    $fullPath = `getAttr ($texNode + ".fileTextureName")`;  }  $fileReadable = `filetest -f $fullPath`;  if ($fileReadable) {    return $fullPath;  } else {    return "";  }}proc string getTextureFullPath2(string $texNode) {  string $fullPath;  if (`nodeType $texNode` == "mentalrayIblShape") {    $fullPath = `getAttr ($texNode + ".texture")`;  } else {    $fullPath = `getAttr ($texNode + ".fileTextureName")`;  } return $fullPath;}// get the texture file name of a texture nodeproc string getTextureFileName(string $texNode) {  int $fileReadable;  string $textureFileName;  string $fullPath = getTextureFullPath($texNode);  $fileReadable = `filetest -f $fullPath`;  if ($fileReadable) {    string $tmp[] = stringToStringArray($fullPath, "/");    $textureFileName = $tmp[size($tmp)-1];    return $textureFileName;  } else {    return "";  }}// change file texture into relative pathproc string toRelativePath(string $path) {  string $relativePath;  string $dirs[] = stringToStringArray($path, "/");  int $len = size($dirs);  int $i = $len;  if ($len == 0) {    return "";  }  do {    $i--;    if ($i == $len-1) {      $relativePath = $dirs[$i];    } else if ($i > 0) {      $relativePath = $dirs[$i] + "/" + $relativePath;    } else if ($i == 0) {      $relativePath = "sourceimages/otherTextures/"+$dirs[$len-1];      break;    }  } while ($dirs[$i] != "sourceimages");  return $relativePath;}proc string toRelativePath2(string $path) {  string $relativePath;  string $dirs[] = stringToStringArray($path, "/");  int $len = size($dirs);  int $i = $len;  if ($len == 0) {    return "";  }  do {    $i--;    if ($i == $len-1) {      $relativePath = $dirs[$i];    } else if ($i > 0) {      $relativePath = $dirs[$i] + "/" + $relativePath;    } else if ($i == 0) {      $relativePath = "sourceimages/otherTextures/"+$dirs[$len-1];      break;    }  } while ($dirs[$i] != "sourceimages");    string $relativePath2="";  string $dirs2[] = stringToStringArray($relativePath, "/");    int $j;  if($dirs2[0]=="sourceimages")  {  for($j=1;$j<size($dirs2);$j++)  {    $relativePath2 = $relativePath2 + $dirs2[$j] + "/";  }  }  if(!($relativePath2==""))  return $relativePath2;    else   return $relativePath;}// check texturesglobal proc fh_checkTextures() {  string $allTextureNodes[] = fh_getTextureNodes();  string $result = "";  string $fullPath;  int $fileReadable;  int $missingTexCount;  for ( $textureNode in $allTextureNodes) {    $fullPath = getTextureFullPath($textureNode);    $fileReadable = `filetest -f $fullPath`;    if ( $fullPath == "" ) { // texture field empty      $missingTexCount++;      $result += ("节点 " + $textureNode + " 贴图路径为空！\n");      continue;    } else if (!$fileReadable) { // texture file not readable      $missingTexCount++;      $result += ("找不到节点 " + $textureNode + " 的贴图：\n" + $fullPath + "\n");    }  }  $result = ($missingTexCount + " 个贴图丢失！\n" + $result);  //scrollField -edit -text $result fh_textureCheckResultField;}// copy ( backup ) or move ( transfer ) textures to a specific directory global proc fh_textureOp( int $op) {  string $oldPath;  string $newPath;  string $fileName;  string $newRelativePath;  string $allTextureNodes[] = fh_getTextureNodes();  int $setRelativePath = 0;  int $resetNewPath = `checkBox -query -value fh_setPathCB`;  string $dstDirectory = `textField -query -fileName fh_dstDirField`;  if (!`filetest -d $dstDirectory`) { // make sure destination dir is valid    confirmDialog       -title "无效目录"      -message "指定目标目录无效，请选择一个有效目录！\n"      -messageAlign center      -parent fh_textureManagerWin      -button "关闭";    return;  }  waitCursor -state on;  print "正在备份（转移）贴图，请稍候……\n";  for ($textureNode in $allTextureNodes) {    $oldPath = getTextureFullPath($textureNode);    $fileName = getTextureFileName($textureNode);    $newRelativePath = toRelativePath($oldPath);    if ($oldPath == "" || $fileName == "") {      continue;    } else if (endsWith($dstDirectory, "/")) { // check if destination dir ends with "/"      $newPath = $dstDirectory + $newRelativePath;    } else {      $newPath = $dstDirectory + "/" + $newRelativePath;    }    $newDir = dirname($newPath);    if (!`filetest -d $newDir`) { // check if new path exists, if not, create it      sysFile -md $newDir;    }    switch ($op) {      case 0 : // copy        sysFile -cp $newPath $oldPath;      break;      case 1 : // move        sysFile -move $newPath $oldPath;      break;    }    if ($resetNewPath == 1) {      if (`about -nt`) {        $newPath = toNativePath($newPath);      }      setAttr ($textureNode + ".fileTextureName") -type "string" $newPath;    }  }  waitCursor -state off;  print("贴图备份（转移）至 " + $dstDirectory + "\n");}global proc fh_moveUnuseWarn(){    string $title;    $title = "警告！";	int $width = 250;	int $height = 200;	    //create window	if(`window -q -exists warnWin`){    	deleteUI warnWin;    }    string $win = `window -title $title -widthHeight $width $height warnWin`;        //////////////     // create a formLayout       string $form= `formLayout`;    ///////////////////       string $textUI =`text -l "执行此功能前必须确保项目中只有此一个场景文件。"` ;       string $textUI2 =`text -l "移除后将不能复原。"` ;       string $textUI3 =`text -l "是否移除无用贴图？"` ;	   string $confirmUI=`button -w 80 -h 20 -label "是"  -c fh_moveUnuse` ;       string $unconfirmUI=`button -w 80 -h 20 -label "否"  -c deleteWin` ;  /////////////////////////      formLayout -edit       -attachForm $textUI "top" 10       -attachForm $textUI "left" 10       -attachForm $textUI2 "top" 30       -attachForm $textUI2 "left" 10       -attachForm $textUI3 "top" 50       -attachForm $textUI3 "left" 10       -attachForm $confirmUI "top" 80       -attachForm $confirmUI "left" 10       -attachForm $unconfirmUI "top" 80       -attachForm $unconfirmUI "left" 110    $form;    ///////////////////       setParent..;    //////////////    showWindow $win;}global proc fh_toRelativeWarn(){    string $title;    $title = "警告！";	int $width = 250;	int $height = 200;	    //create window	if(`window -q -exists warnWin2`){    	deleteUI warnWin2;    }    string $win = `window -title $title -widthHeight $width $height warnWin2`;        //////////////     // create a formLayout       string $form= `formLayout`;    ///////////////////       string $textUI =`text -l "该功能不能使用于有参考物体的场景。"` ;       string $textUI2 =`text -l "将贴图路径转换后将不能复原。"` ;       string $textUI3 =`text -l "是否转换贴图路径？"` ;	   string $confirmUI=`button -w 80 -h 20 -label "是"  -c fh_toRelative` ;       string $unconfirmUI=`button -w 80 -h 20 -label "否"  -c deleteWin2` ;  /////////////////////////      formLayout -edit       -attachForm $textUI "top" 10       -attachForm $textUI "left" 10       -attachForm $textUI2 "top" 30       -attachForm $textUI2 "left" 10       -attachForm $textUI3 "top" 50       -attachForm $textUI3 "left" 10       -attachForm $confirmUI "top" 80       -attachForm $confirmUI "left" 10       -attachForm $unconfirmUI "top" 80       -attachForm $unconfirmUI "left" 110    $form;    ///////////////////       setParent..;    //////////////    showWindow $win;}global proc fh_toRelative(){deleteUI warnWin2;    string $newDir;  string $newDir2;  string $newPath2;  string $allTextureNodes[] = fh_getTextureNodes();  for ($textureNode in $allTextureNodes){   $oldPath = getTextureFullPath2($textureNode);    int $i,$j;    string $newRelativePath="";      if ($oldPath != "" )     {        string $tempArray[] = stringToStringArray($oldPath, "/");        int $ifExistSource = 0;              for($i=0; $i<size($tempArray); $i++)        {          if($tempArray[$i]=="sourceimages")          {            $ifExistSource = 1;            for($j=$i; $j<(size($tempArray)-1); $j++)            {              $newRelativePath = $newRelativePath + $tempArray[$j] + "/";            }              $newRelativePath = $newRelativePath + $tempArray[size($tempArray)-1] ;                        string $currentPro = currentProject();                        if (`filetest -f ( $currentPro + $newRelativePath)`)            {            setAttr ($textureNode + ".fileTextureName") -type "string" $newRelativePath;            }                        else            {              $newPath2 = $currentPro + $newRelativePath;                            $newDir2 = dirname($newPath2);                            if (!`filetest -d $newDir2`)                 { // check if new path exists, if not, create it                sysFile -md $newDir2;                 }                               sysFile -copy $newPath2 $oldPath;              setAttr ($textureNode + ".fileTextureName") -type "string" $newRelativePath;            }                       break;          }                }          if($ifExistSource == 0)          {            string $otherRelative = toRelativePath($oldPath);            $noProPath = currentProject() + $otherRelative;                        $newDir = dirname($noProPath);              if (!`filetest -d $newDir`) { // check if new path exists, if not, create it                 sysFile -md $newDir;                }          sysFile -copy $noProPath $oldPath;          setAttr ($textureNode + ".fileTextureName") -type "string" $otherRelative;          }    }}}global proc lls_checkTexture(){string $allTextureNodes[] = fh_getTextureNodes();for ($textureNode in $allTextureNodes){//$oldPath = getTextureFullPath($textureNode);//$newRelativePath = toRelativePath($oldPath);$newRelative = `getAttr ($textureNode + ".fileTextureName")`;print ($newRelative + "\n");}}global proc deleteWin(){  deleteUI warnWin;}global proc deleteWin2(){  deleteUI warnWin2;}global proc fh_moveUnuse(){  deleteUI warnWin;    string $oldPath;  string $newPath;  string $fileName;  string $newRelativePath;  string $allTextureNodes[] = fh_getTextureNodes();     string $projectPath = currentProject();    if(!`filetest -d  $projectPath`)  sysFile -makeDir $projectPath;    string $dstDirectory = $projectPath + "tempFolder";    waitCursor -state on;    print "正在转移无用贴图，请稍候……\n";    for ($textureNode in $allTextureNodes)   {        $oldPath = getTextureFullPath($textureNode);    $fileName = getTextureFileName($textureNode);    $newRelativePath = toRelativePath2($oldPath);        if ($oldPath == "" || $fileName == "") {      continue;    } else if (endsWith($dstDirectory, "/")) { // check if destination dir ends with "/"      $newPath = $dstDirectory + $newRelativePath;    } else {      $newPath = $dstDirectory + "/" + $newRelativePath;    }        $newDir = dirname($newPath);        if (!`filetest -d $newDir`) { // check if new path exists, if not, create it      sysFile -md $newDir;    }       sysFile -move $newPath $oldPath;  }       string $sourcePath = $projectPath + "sourceimages";     string $unuseDirectory = $projectPath + "unuseSourceImages";       if(!(`filetest -d $unuseDirectory`))       sysFile -md $unuseDirectory;          $unUseFolder = `getFileList -folder ($unuseDirectory + "/")`;     $sizeFolder = size($unUseFolder);          $unuseDirectory = $unuseDirectory + "/folder" + string ($sizeFolder+1);           moveBetweenFolders($unuseDirectory, $sourcePath);     moveBetweenFolders($sourcePath, $dstDirectory);       waitCursor -state off;    print("已经将无用贴图转移至当前项目的unuse sourceimages目录下！");    }global proc moveBetweenFolders(string $newFolder, string $oldFolder){   if(!(`filetest -d $newFolder`))       sysFile -md $newFolder;      $oldPath = `getFileList -folder ($oldFolder + "/")`;        for($sele in $oldPath)       {         sysFile -move ($newFolder + "/"+$sele) ($oldFolder + "/" +$sele);       }}global proc string currentProject (){    $currentDir = `file -q -exn`;    $sceneFolder = "scenes";        int $i,$j;    string $projectPath = "";        string $dirs[] = stringToStringArray($currentDir, "/");        for($i=(size($dirs)-1);$i>=0;$i--)    {        if($dirs[$i]==$sceneFolder)        {            for($j=0;$j<$i;$j++)              {                  $projectPath = $projectPath + $dirs[$j] + "/";              }        return $projectPath;        }    }      return -1;}global proc fh_dstDirBrowse() {  // called when user press "目标目录" button  setParent fh_textureOpTab;  string $initialDirectory = `textField -query -fileName fh_dstDirField`;  fileBrowser("fh_updateDstDirField", "Open", "", 4);}global proc int fh_updateDstDirField(string $directory, string $type) {  // if dir is valid, return 1 and close the dirbrowser, else return 0 and the dirbrowser keept opened  if (`filetest -d $directory`) {    setParent fh_textureOpTab;    textField -edit -fileName $directory fh_dstDirField;    return 1;  } else {    confirmDialog      -title "无效目录"      -message "指定目标目录无效，请选择一个有效目录！\n"      -messageAlign center      -button "关闭";    return 0;  }}global proc fh_textureManagerHelp() {  string $helpText;  $helpText = "　　在“检查贴图”页面，先检查丢失的贴图，然后，在“操作”标签，可以把贴图备份或转移（剪切）到指定目录，同时可以选择是否把贴图路径指定到新的位置。";  scrollField -edit -text $helpText fh_textureCheckResultField;}global proc fh_analyseTextures(string $parentLayout){	setParent $parentLayout;    if (`scrollLayout -q -ex ($parentLayout + "|analysisCheckerScroll")`)		deleteUI ($parentLayout + "|analysisCheckerScroll");    waitCursor -state on;    scrollLayout analysisCheckerScroll;    columnLayout -adj 1 analysisCheckerColumn;    text -label "" -align "left" resultInfo;    text -label "";    int $numInvalid = 0;    string $textureFiles[] = `ls -typ file -typ psdFileTex -typ mentalrayTexture`;    for($file in  $textureFiles)    {        string $path = `getAttr ($file + ".fileTextureName")`;        //string $name = `getAttr ($file + ".cacheName")`;       // string $fullPath =  $path + $name;       // string $fullCacheXml = $path + $name + ".xml";        if(!`filetest -r $path`)        {            checkBox -l ("找不到节点" + $file + "的贴图.") -al left -onc ("if (`objExists " + $file + "` ) select -add " + $file) -ofc ("if (`objExists " + $file + "` ) select -deselect " + $file);        	$numInvalid++;           // setParent ($parentLayout + "|analysisCheckerColumn");        }    }    text -e -label ("共计" + $numInvalid + "个贴图路径不存在!") resultInfo;    waitCursor -state off;}global proc cleanResult(string $parentLayout){  setParent $parentLayout; if (`scrollLayout -q -ex ($parentLayout + "|analysisCheckerScroll")`)		deleteUI ($parentLayout + "|analysisCheckerScroll");}// GUIglobal proc fh_textureManagerGUI() {  // If the window already exists then just show it and return  if (`window -exists fh_textureManagerWin`) {    showWindow fh_textureManagerWin;    return;  }  window -title "贴图整理" -w 400 -h 360 -menuBar yes fh_textureManagerWin;  menu -label "帮助" -enable yes -helpMenu yes fh_textureManagerHelpMenu;    menuItem -label "显示使用说明" -command "fh_textureManagerHelp()";  string $tabName = `tabLayout -innerMarginWidth 5 -innerMarginHeight 5`;    formLayout fh_textureCheckTab;      button -label "检查贴图"  fh_checkTextureButton;      string $analyseFrame = `frameLayout -label "分析结果" analyseFrame`;      //string $scroll = `scrollLayout`;      //setParent ..;      setParent ..;      button -e -command ("fh_analyseTextures " + $analyseFrame) fh_checkTextureButton;      button -label "清空结果"        -command ("cleanResult " + $analyseFrame)        fh_clearResultButton;      button -label "取消"        -command "deleteUI fh_textureManagerWin"        fh_textureManagerWinCloseBtn;    setParent ..;    formLayout fh_textureOpTab;      button -label "移除无用贴图" -command "fh_moveUnuseWarn" fh_moveUnuseButton;      button -label "贴图绝对路径转相对路径" -command "fh_toRelativeWarn" fh_toRelativeButton;      separator sepSign;      textField -enable yes -text "" -width 300 fh_dstDirField;      button -label "目标目录" -command "fh_dstDirBrowse()" fh_setDstDirButton;      checkBox -label "修改贴图路径" -align "left" fh_setPathCB;      button -label "复制贴图" -command "fh_textureOp(0)" fh_texCpButton;      button -label "剪切贴图" -command "fh_textureOp(1)" fh_texMvButton;            button -label "完成"        -command "deleteUI fh_textureManagerWin"        fh_textureOpDoneBtn;    setParent ..;  tabLayout -edit    -tabLabel fh_textureCheckTab "检查贴图"    -tabLabel fh_textureOpTab "操作"    $tabName;  setParent ..;  int $spacing = 5;  formLayout -e    -attachForm fh_checkTextureButton "left" $spacing    -af fh_checkTextureButton "top" $spacing    -attachPosition fh_checkTextureButton "right" $spacing 50    -ap fh_clearResultButton "left" $spacing 50    -af fh_clearResultButton "top" $spacing    -af fh_clearResultButton "right" $spacing    -af analyseFrame "left" $spacing    -af analyseFrame "right" $spacing    -attachControl analyseFrame "top" $spacing fh_checkTextureButton    -ac analyseFrame "bottom" $spacing fh_textureManagerWinCloseBtn    -af fh_textureManagerWinCloseBtn "left" $spacing    -af fh_textureManagerWinCloseBtn "right" $spacing    -an fh_textureManagerWinCloseBtn "top"    -af fh_textureManagerWinCloseBtn "bottom" $spacing    fh_textureCheckTab;  formLayout -e    -af fh_moveUnuseButton "left" $spacing    -af fh_moveUnuseButton "top" $spacing     -af fh_moveUnuseButton "right" $spacing    -af fh_toRelativeButton "left" $spacing    -ac fh_toRelativeButton "top" $spacing fh_moveUnuseButton    -af fh_toRelativeButton "right" $spacing        -af sepSign "left" $spacing    -af sepSign "right" $spacing    -ac sepSign "top" 10 fh_toRelativeButton        -af fh_dstDirField "left" $spacing    -ac fh_dstDirField "top" $spacing sepSign    -attachNone fh_dstDirField "right"        -ac fh_setDstDirButton "left" $spacing fh_dstDirField    -ac fh_setDstDirButton "top" 10 sepSign    -af fh_setPathCB "left" $spacing    -ac fh_setPathCB "top" $spacing fh_dstDirField    -af fh_setPathCB "right" $spacing    -af fh_texCpButton "left" $spacing    -ac fh_texCpButton "top" $spacing fh_setPathCB    -ap fh_texCpButton "right" $spacing 50    -ap fh_texMvButton "left" $spacing 50    -ac fh_texMvButton "top" $spacing fh_setPathCB    -af fh_texMvButton "right" $spacing        -af fh_textureOpDoneBtn "left" $spacing    -af fh_textureOpDoneBtn "right" $spacing    -an fh_textureOpDoneBtn "top"    -af fh_textureOpDoneBtn "bottom" $spacing    fh_textureOpTab;  window -e -w 400 -h 300 fh_textureManagerWin;  showWindow fh_textureManagerWin;}fh_textureManagerGUI();