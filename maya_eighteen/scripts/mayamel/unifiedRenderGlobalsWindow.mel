// ===========================================================================
// Copyright 2017 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
global string $gMasterLayerRendererName = "masterLayer";

// Description:
//		Find all renderers currently in use in this scene based on overrides
//		to defaultRenderGlobals.currentRenderer. This is used by
//		isDisplayingAllRendererTabs() to determine if it is necessary to
//		display tabs for more than one renderer on the master layer. Note
//		that if more than one renderer is in use in the scene, ALL renderer
//		tabs will be displayed. Getting only the relevant tabs to display
//		was proving too error-prone in this fragile code.
//
proc string[] getAllUsedRenderers()
{
	// result always includes current renderer
	string $currentRendererName = currentRenderer();
	string $result[] = { $currentRendererName };

	string $allRenderers[] = `renderer -query -namesOfAvailableRenderers`;
	string $connections[] = `listConnections -p true -type "renderLayer" defaultRenderGlobals.currentRenderer`;
	for ($c in $connections) {
		// if this is an adjustment plug, get the matching value
		if (`match "\\.adjustments\\[[0-9]*\\].plug" $c` != "") {
			// strinp off "plug" and replace with "value"
			string $valueAttr = `substring $c 1 (size($c) - 4)`;
			$valueAttr += "value";
			string $renderer = "";
			catch($renderer = eval("getAttr " + $valueAttr));
			// if the value of the attribute is a registered renderer
			// then add it to the list
			if (stringArrayContains($renderer, $allRenderers) && !stringArrayContains($renderer, $result)) {
				$result[size($result)] = $renderer;
			}
		}
	}
	return $result;
}

global proc int isValidFileNamePrefix(string $prefix)
{
	int $isValid = 1;

	if (match("[*?\"|!$]", $prefix) != "")
	{
		// Most of these characters may not occur in NT filenames
		// The ' ', '!' and '$' are troublesome on Unix.
		//
		catch(error (uiRes("m_unifiedRenderGlobalsWindow.kInvalidCharacters")));
		$isValid = 0;
	}
	return $isValid;
}


// Description:
//		Checks whether we're displaying all renderer tabs in the
//		Render Settings window.
//
// Returns:
//		true	if more than 1 render layer exists & we're on the master layer
//				and the user is using multiple renderers in their scene
//		false	otherwise
//
global proc int isDisplayingAllRendererTabs()
{
    if (!`objExists renderLayerManager`) {
      return false;
    }

	string $layerNames[] = `listConnections renderLayerManager.renderLayerId`;
	int $numLayers = `size($layerNames)`;

	if( $numLayers > 1 )
	{
		string $currentLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
		int $numRenderers = size(getAllUsedRenderers());

		if (0 == `getAttr ($currentLayer + ".identification")` && $numRenderers > 1) {
			// We are currently on the master layer
			return true;
		}
	}
	return false;
}

proc string findTabForUpdateProc(string $updateProc, string $tabLayoutName, string $tabLayoutPrefix)
{
	// Find the tab that this updateProc corresponds to
	// eg For proc called updateMentalRayFeaturesTab, find tab named masterLayerFeaturesTab
	string $updateTab = "";
	// prefix is either "masterLayer", or "mentalRay", "mayaSoftware" etc.
	int $prefixNameSize = size($tabLayoutPrefix);
	string $tabNames[] = `tabLayout -q -ca $tabLayoutName`;
	string $tab;
	for ($tab in $tabNames)
	{
		int $nameSize = size($tab);
		// strip off prefix eg "masterLayer" from the beginning and "tab" from the end
		string $whichTab = `substring $tab ($prefixNameSize+1) ($nameSize-3)`;
		if (`match $whichTab $updateProc` == $whichTab)
		{
			$updateTab = $tab;
			break;
		}
	}

	// A few procs don't conform to the pattern above
	if ($tabLayoutPrefix == "masterLayer")
	{
		if ($updateProc == "updateMayaRenderPassTab")
			$updateTab = "masterLayerPassesTab";
		else if ($updateProc == "updateVectorGlobalsTab")
			$updateTab = "masterLayerMayaVectorTab";
	}
	else if ($tabLayoutPrefix == "mentalRay")
	{
		if ($updateProc == "updateMayaRenderPassTab")
			$updateTab = "mentalRayPassesTab";
	}
	return $updateTab;
}

// Description:
//		Updates the tabs for the special master layer layout.
//
global proc updateMasterLayerTabs()
{
	// Unmanage the tab layout during the update process
	//
	global string $gMasterLayerRendererName;
	string $tabLayoutName = rendererTabLayoutName($gMasterLayerRendererName);
	tabLayout -edit -manage false $tabLayoutName;

	// Update this renderer's tabs
	//
	int $i;
	string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
	string $currentRenderer = currentRenderer();
	string $tabNames[] = `tabLayout -q -ca $tabLayoutName`;

	for ($i = 0; $i < size($renderers); $i++){
		string $renderer = $renderers[$i];

		// Get the update procedure names
		string $tabUpdateProcs[] = `renderer -query -globalsTabUpdateProcNames $renderer`;
		string $proc;
		for ($proc in $tabUpdateProcs)
		{
			// Find the tab that this updateProc corresponds to
			// eg For proc called updateMentalRayFeaturesTab, find tab named masterLayerFeaturesTab
			string $updateTab = findTabForUpdateProc($proc, $tabLayoutName, "masterLayer");

			string $tabChildren[] = {};
			if ($updateTab != "")
				$tabChildren = `formLayout -q -ca $updateTab`;
			if ( (size($tabChildren) != 0) && ($proc != "") )
			{
				// Only update the tab if its content has already been created
				eval($proc);
			}
		}
	}

	// Update the tab selection to reflect the current renderer.
	// If the common tab is selected, or if the selected tab is already one
	// of the tabs for the current renderer do not change the tab selection.
	// Otherwise select the first tab of the current renderer.
	//
	int $selectedTabIdx = `tabLayout -q -selectTabIndex $tabLayoutName`;
	if ($selectedTabIdx > 1) {
		string $selectedTabName = `tabLayout -q -selectTab $tabLayoutName`;
		string $temp[] = `renderer -q -globalsTabLabels $currentRenderer`;
		string $currRenderTabs[];
		for ($tab in $temp) {
			$currRenderTabs[size($currRenderTabs)] =
				rendererTabName($gMasterLayerRendererName, $tab);
		}

		if (!stringArrayContains($selectedTabName, $currRenderTabs)) {
			string $allTabs[] = `tabLayout -q -childArray $tabLayoutName`;
			int $numTabs = size($allTabs);
			// skip common tab
			for ($i=1; $i<$numTabs; $i++) {
				if (stringArrayContains($allTabs[$i], $currRenderTabs)) {
					tabLayout -edit -selectTab $allTabs[$i] $tabLayoutName;
					break;
				}
			}
		}
	}

	// Now manage the tab
	//
	tabLayout -edit -manage true $tabLayoutName;
}


// Description:  This procedure is called to show the current
//      renderer's tabLayout and hide all the other renderers'
//      tabLayout.
//
proc manageCurrentRendererTabLayout()
{
	// This will prevent the errors associated with the tabForm not being present at that time.
	if (!`formLayout -q -exists tabForm`) return;

    // Change the tabForm to show only the tabLayout associated with the
    // current renderer.
    //
    string $tabLayouts[] = `formLayout -query -childArray tabForm`;

	// Unmanage all the tabLayout.
	//
	for ($i = 0; $i < size($tabLayouts); $i++)
	{
		tabLayout -edit -manage false $tabLayouts[$i];
	}

	if( isDisplayingAllRendererTabs() )
	{
		// Manage only the master layer tabLayout. If it doesn't exist,
		// create it.
		//
		global string $gMasterLayerRendererName;
		string $tabLayoutName = rendererTabLayoutName($gMasterLayerRendererName);

		if (!`tabLayout -exists $tabLayoutName`)
		{
			addMasterLayerTabsToGlobalsWindow();
		}
		tabLayout -edit -manage true $tabLayoutName;
	}
	else
	{
		// Manage only the tabLayout associated with the current renderer.
		//
		string $renderer = currentRenderer();
		string $tabLayoutName = rendererTabLayoutName($renderer);

		// If the tabLayout for the current renderer does not exists
		// yet, then add it to the window.
		//
		if (!`tabLayout -exists $tabLayoutName`)
		{
			addRendererTabsToGlobalsWindow($renderer);
		}
		tabLayout -edit -manage true $tabLayoutName;
	}
}

//==================================================================
//
// Starting the Window building section
//
//==================================================================

proc updateCurrentRendererTabs()
{
	//
	// Description:
	//	This procedure is called when an event has occurred which may have
	//	invalidated information contained in the tabs of the render globals
	//	window. This can occur, for example, when the current renderer changes.
	//	This procedure calls the tab updating procedures that were registered
	//	with Maya when the various renderers registered themselves.
	//

	int $preventUpdate = false;
	if( `workspaceControl -exists unifiedRenderGlobalsWindow` &&
		! `workspaceControl -query -visible unifiedRenderGlobalsWindow` ){
		// Don't update the tabs if the window isn't visible.
		// Updates may take a long time (bug 233040) and should be avoided
		// when possible
		//
		$preventUpdate = true;
	}

	if( isDisplayingAllRendererTabs() )
	{
		// Check if the master layer tabLayout exists or not.
		//
		global string $gMasterLayerRendererName;
		string $tabLayoutName = rendererTabLayoutName($gMasterLayerRendererName);
		if (!`tabLayout -exists $tabLayoutName`)
		{
			// Delete existing tabLayouts
			string $tabLayouts[] = `formLayout -query -childArray tabForm`;
			for ($i = 0; $i < size($tabLayouts); $i++)
			{
				// On windows we always delete the previous tabLayout, because
				// of desktop heap memory issues (298476) - on other platforms
				// we always keep the masterLayTabLayout around to speed things up
				// when switching between eg default render layer and other layer
				if (`about -win` || ($tabLayouts[$i] != "masterLayerTabLayout"))
				{
					deleteUI $tabLayouts[$i];
				}

			}
			// Create it.
			//
			addMasterLayerTabsToGlobalsWindow();
		}
		else if( ! $preventUpdate )
		{
			// Update this master layer's tabs.
			//
			updateMasterLayerTabs();
		}
   	}
	else
	{
		// Update only current renderer's tabLayout
		//
		string $renderer = currentRenderer();

		// Check if the tabs for this renderer exists or not.
		//
		string $tabLayoutName = rendererTabLayoutName($renderer);
		if (!`tabLayout -exists $tabLayoutName`)
		{
			// If this renderer's tabLayout doesn't exist, it means we will be creating it
			// so delete the one(s) that exist right now
			if(`formLayout -exists tabForm`)
			{
				string $tabLayouts[] = `formLayout -query -childArray tabForm`;
				for ($i = 0; $i < size($tabLayouts); $i++)
				{
					if (`about -win` || ($tabLayouts[$i] != "masterLayerTabLayout"))
					{
						// See note above about bug 298476
						deleteUI $tabLayouts[$i];
					}

				}
				$tabLayouts = `formLayout -query -childArray tabForm`;
			}
			// Create it.
			//
			addRendererTabsToGlobalsWindow($renderer);
		}
		else if( ! $preventUpdate )
		{
			// Update this renderer's tabs.
			//
			string $tabUpdateProcs[];

			$tabUpdateProcs =
				`renderer -query -globalsTabUpdateProcNames $renderer`;

			string $proc;

			for ($proc in $tabUpdateProcs)
			{
				string $tabLayoutName = rendererTabLayoutName($renderer);
				string $tabNames[] = `tabLayout -q -ca $tabLayoutName`;

				string $updateTab = findTabForUpdateProc($proc, $tabLayoutName, $renderer);

				string $tabChildren[] = {};
				if ($updateTab != "")
					$tabChildren = `formLayout -q -ca $updateTab`;
				if ( (size($tabChildren) != 0) && ($proc != "") )
				{
					// Only update the tab if its content has already been created
					eval($proc);
				}
			}
		}
	}

	// Manage only current renderer's tabLayout.
	//
	manageCurrentRendererTabLayout();

}

proc updateCurrentRendererLogo()
{
    //
    // Description:
    //  This procedure is called when an event has occurred which may have
    //  invalidated the picture of the renderer logo in the render globals
    //  window. This can occur, for example, when the current renderer changes.
    //  This procedure calls the logo updating procedures that were registered
    //  with Maya when the various renderers registered themselves.
    //

    if (!`symbolButton -exists unifiedRenderGlobalsRendererLogoPicture`)
    {
        // The logo has not been created.
        //
        return;
    }

    // If the current renderer has specified both a logo image and callback,
    // enable the symbol button UI to show the logo.
    // By default, the logo is invisible.
    //
    string $imageName = `renderer -query -logoImageName (currentRenderer())`;
    string $logoCallback = `renderer -query -logoCallbackProcedure (currentRenderer())`;
	string $logoAnnotation = (uiRes("m_unifiedRenderGlobalsWindow.kLogoAnnot"));

    if ( 0 < size($imageName) && 0 < size($logoCallback) )
    {
        symbolButton
            -edit
            -image $imageName
            -command $logoCallback
			-annotation $logoAnnotation
            -visible true
            unifiedRenderGlobalsRendererLogoPicture;
    }
    else
    {
        symbolButton
            -edit
            -visible false
            unifiedRenderGlobalsRendererLogoPicture;
    }

}

// Description: Called when the user selects a new layer from the
//              Layer option menu
global proc updateCurrentRenderLayerSel()
{
	setParent unifiedRenderGlobalsWindow;

	string $currLayer = `editRenderLayerGlobals -q -currentRenderLayer`;

	// Get the layer node name and display name for the newly selected layer.
	// The node name is stored in the annotation string and the display name in 
	// the label on the menuItem in the optionMenu
	string $items[] = `optionMenu -q -itemListLong unifiedRenderGlobalsRenderLayerOptionMenu`;
	int $selected = `optionMenu -q -select unifiedRenderGlobalsRenderLayerOptionMenu`;
	string $newLayer = `menuItem -q -annotation $items[$selected-1]`;
	string $newLayerLabel = `menuItem -q -label $items[$selected-1]`;

	if ($currLayer != $newLayer &&
			`objExists $newLayer` &&
			`nodeType $newLayer` == "renderLayer") {
		if(catch(`editRenderLayerGlobals -currentRenderLayer $newLayer`))
			optionMenu -e -value $newLayerLabel unifiedRenderGlobalsRenderLayerOptionMenu;
	}
}

// Description: Update the layer list and current selected layer,
//              called when an update is triggered on the window
//
global proc updateRenderLayerOptionMenu()
{
	setParent unifiedRenderGlobalsWindow;

    if (!`objExists renderLayerManager`) {
      return;
    }

	string $layers[] = `listConnections renderLayerManager.renderLayerId`;
	if (size($layers) > 0) {
		string $currLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
		$layers = sortLayers($layers);
		int $numLayers = size($layers);

		string $menuItemNames[] = `optionMenu -q -itemListLong unifiedRenderGlobalsRenderLayerOptionMenu`;
		int $numItems = size($menuItemNames);

		// script job stuff
		string $updateScript = ("evalDeferred -lowestPriority \"updateUnifiedRenderGlobalsWindowSpecifiedUI\"");
		int $jobsReplaced = false;

		int $i = 0;
		string $currItem = "";
		for ($i=0; $i<$numLayers; $i++) {
			// reverse order for layers to match render layer editor
			string $layer = $layers[$numLayers - $i - 1];
			string $label = renderLayerDisplayName($layer);
			if ($layer == $currLayer) {
				$currItem = $label;
			}

			if ($i >= $numItems) {
				menuItem
					-label $label
					-annotation $layer
					-parent unifiedRenderGlobalsRenderLayerOptionMenu;
			} else {
				menuItem -edit
					-label $label
					-annotation $layer
					$menuItemNames[$i];
			}

			if ($jobsReplaced) {
				scriptJob -parent unifiedRenderGlobalsRenderLayerOptionMenu
					-nodeNameChanged $layer $updateScript;
			} else {
				scriptJob -replacePrevious -parent unifiedRenderGlobalsRenderLayerOptionMenu
					-nodeNameChanged $layer $updateScript;
				$jobsReplaced = true;
			}
		}

		// delete extras
		for (; $i<$numItems; $i++) {
			deleteUI $menuItemNames[$i];
		}

		// reset selection
		if ($currItem != "") {
			optionMenu -edit -value $currItem
				unifiedRenderGlobalsRenderLayerOptionMenu;
		}
	}
}

// Description: Load presets for several nodes together.
//
global proc loadNodePresets( string $name )
{
	int $i;
	string $globalsNodes[] = `renderer -q -globalsNodes (currentRenderer())`;

	for ($i = 0; $i < size($globalsNodes); $i++)
	{
		if(`nodePreset -exists $globalsNodes[$i] $name`) {
			nodePreset -load $globalsNodes[$i] $name;
		}
	}

	updateObjTypeFilterToCheckBox();

}

// Remove presets for several nodes together.
global proc removePreferedPresets( )
{
	int $i;
    string $currentRenderer = currentRenderer();
	string $globalsNodes[] = `renderer -q -globalsNodes $currentRenderer`;

	for ($i = 0; $i < size($globalsNodes); $i++)
	{
		optionVar -remove ($currentRenderer + $globalsNodes[$i] + "PreferredPreset");
	}
}

// Set prefered presets for several nodes together.
global proc setPreferedPreset( string $name )
{
	int $i;
    string $currentRenderer = currentRenderer();
	string $globalsNodes[] = `renderer -q -globalsNodes $currentRenderer`;

	for ($i = 0; $i < size($globalsNodes); $i++)
	{
        string $preferredPresetOptVar = $currentRenderer + $globalsNodes[$i] + "PreferredPreset";
		if(`nodePreset -exists $globalsNodes[$i] $name`) {
			optionVar -stringValue $preferredPresetOptVar $name;
		}
        else {
            optionVar -remove $preferredPresetOptVar;
        }
	}
}

// Remove render setup preset
global proc removeRenderSetupPreferredPresets( )
{
	string $preferredRenderSetupPresetOptVar = (currentRenderer() + "PreferredRenderSetupPreset");
	optionVar -remove $preferredRenderSetupPresetOptVar;
	
	string $preferredRenderSetupPresetTypeOptVar = (currentRenderer() + "PreferredRenderSetupPresetType");
	optionVar -remove $preferredRenderSetupPresetTypeOptVar;
}

// Set preferred render setup preset
global proc setPreferredRenderSetupPreset( string $name, int $user )
{
	string $globalRenderSetupPreset = (uiRes("m_unifiedRenderGlobalsWindow.kGlobalRenderSetupPreset"));
	string $userRenderSetupPreset = (uiRes("m_unifiedRenderGlobalsWindow.kUserRenderSetupPreset"));

	string $preferredRenderSetupPresetOptVar = (currentRenderer() + "PreferredRenderSetupPreset");
	optionVar -stringValue $preferredRenderSetupPresetOptVar $name;
	
	string $preferredRenderSetupPresetTypeOptVar = (currentRenderer() + "PreferredRenderSetupPresetType");
	string $type = $globalRenderSetupPreset;
	if ($user)
		$type = $userRenderSetupPreset;
	optionVar -stringValue $preferredRenderSetupPresetTypeOptVar $type;
}

// Revert all the setting to the defaults
global proc unifiedRenderGlobalsRevertToDefault()
{
	int $i;

	// Save selection, because the createNode commands will change it.
	string $sel[] = `ls -sl`;
    string $currentRender = currentRenderer();
	string $globalsNodes[] = `renderer -q -globalsNodes $currentRender`;

	for ($i = 0; $i < size($globalsNodes); $i++)
	{
		string $node = $globalsNodes[$i];
		if (objExists($node))
		{
			string $type = `nodeType $node`;
			if($currentRender != "mayaSoftware" && ($type == "renderGlobals" || $type == "resolution"))
				continue;
			string $default = `createNode $type`;
			copyNode $default $node;
			delete $default;
		}
	}

    if($currentRender != "mayaSoftware") {
	    // Bug 210571:
	    // Ensure the default resolution for all renderers is 960 x 540
        float $width = 960;
        float $height = 540;
        float $pixelAspect = 1;
        float $deviceAspectRatio = $pixelAspect*($width/$height);
        setAttr defaultResolution.width $width;
        setAttr defaultResolution.height $height;
        setAttr defaultResolution.pixelAspect $pixelAspect;
        setAttr defaultResolution.deviceAspectRatio $deviceAspectRatio;

	    // Bug 227580:
	    // Reset the settings in Common tab to default
        int $renderAll = 1;
	    string $imageFilePrefix = "";
	    int $putFrameBeforeExt	= 0;
	    int $animation = 0;
	    int $periodInExt = 1;
	    int $imageFormat = 7;
	    string $imfPluginKey;
        int $usemayaFileName = 1;
        int $useFrameExt = 0;
	    float $startFrame = 1.0;
	    float $endFrame = 10.0;
	    float $byFrameStep = 1.0;
	    int $extensionPadding = 1;
        int $multiCamNamingMode = 0;
        string $bufferName = "<RenderPassType>:<RenderPass>.<Camera>";
	    int $outFormatControl = 0;
	    string $outFormatExt;
	    int $modifyExtension = 0;
	    float $startExtension = 1.0;
	    float $byExtension = 1.0;
	    string $renderVersion;
        int $animationRange = 1;
	    int $enableDefaultLight = 1;
	    string $preMel;
	    string $postMel;
	    string $preRenderLayerMel;
	    string $postRenderLayerMel;
	    string $preRenderMel;
	    string $postRenderMel;
        int $renderLayerEnable = 0;
	    int $aspectLock = 0;
	    int $imageSizeUnits = 0;
	    float $dotsPerInch = 72.0;
	    int $pixelDensityUnits = 0;
	    int $lockDeviceAspectRatio = 0;

        setAttr "defaultRenderGlobals.renderAll" $renderAll;
	    setAttr -type "string" defaultRenderGlobals.imageFilePrefix $imageFilePrefix;
	    setAttr "defaultRenderGlobals.putFrameBeforeExt" $putFrameBeforeExt;
	    setAttr "defaultRenderGlobals.animation" $animation;
	    setAttr "defaultRenderGlobals.periodInExt" $periodInExt;
	    setAttr "defaultRenderGlobals.imageFormat" $imageFormat;
	    setAttr -type "string" "defaultRenderGlobals.imfPluginKey" $imfPluginKey;
        setAttr "defaultRenderGlobals.useMayaFileName" $usemayaFileName;
        setAttr "defaultRenderGlobals.useFrameExt" $useFrameExt;
	    setAttr "defaultRenderGlobals.startFrame" $startFrame;
	    setAttr "defaultRenderGlobals.endFrame" $endFrame;
	    setAttr "defaultRenderGlobals.byFrameStep" $byFrameStep;
	    setAttr "defaultRenderGlobals.extensionPadding" $extensionPadding;
        setAttr "defaultRenderGlobals.multiCamNamingMode" $multiCamNamingMode;
        setAttr -type "string" "defaultRenderGlobals.bufferName" $bufferName;
	    setAttr "defaultRenderGlobals.outFormatControl" $outFormatControl;
	    setAttr -type "string" "defaultRenderGlobals.outFormatExt" $outFormatExt;
	    setAttr "defaultRenderGlobals.modifyExtension" $modifyExtension;
	    setAttr "defaultRenderGlobals.startExtension" $startExtension;
	    setAttr "defaultRenderGlobals.byExtension" $byExtension;
	    setAttr -type "string" "defaultRenderGlobals.renderVersion" $renderVersion;
        setAttr "defaultRenderGlobals.animationRange" $animationRange;
	    setAttr "defaultRenderGlobals.enableDefaultLight" $enableDefaultLight;
	    setAttr -type "string" "defaultRenderGlobals.preMel" $preMel;
	    setAttr -type "string" "defaultRenderGlobals.postMel" $postMel;
	    setAttr -type "string" "defaultRenderGlobals.preRenderLayerMel" $preRenderLayerMel;
	    setAttr -type "string" "defaultRenderGlobals.postRenderLayerMel" $postRenderLayerMel;
	    setAttr -type "string" "defaultRenderGlobals.preRenderMel" $preRenderMel;
	    setAttr -type "string" "defaultRenderGlobals.postRenderMel" $postRenderMel;
        setAttr "defaultRenderGlobals.renderLayerEnable" $renderLayerEnable;
	    setAttr "defaultResolution.aspectLock" $aspectLock;
	    setAttr "defaultResolution.imageSizeUnits" $imageSizeUnits;
	    setAttr "defaultResolution.dotsPerInch" $dotsPerInch;
	    setAttr "defaultResolution.pixelDensityUnits" $pixelDensityUnits;
	    setAttr "defaultResolution.lockDeviceAspectRatio" $lockDeviceAspectRatio;
    }
	string $allCameras[] = `ls -cameras`;
	for ($i = 0; $i < size($allCameras); $i++)
	{
		if (!strcmp($allCameras[$i], "perspShape"))
			setAttr ($allCameras[$i]+".renderable") 1;
		else
			setAttr ($allCameras[$i]+".renderable") 0;
		setAttr ($allCameras[$i]+".mask") 1;
		setAttr ($allCameras[$i]+".depth") 0;
	}
	updateMayaSoftwareCameraControl();
	select -noExpand $sel;

	createObjectTypeFilters(0);
	resetObjFilterToDefault();

}

global string $RENDER_SETTINGS = "Render Settings";
global string $AOVS = "AOVs";

global proc confirmDialogExportCurrentValues(string $label, string $typeName)
{
	global string $RENDER_SETTINGS;
	global string $AOVS;
	
	int $hasApplyOverrides = 0;
	string $popUpMsg;
	if ($typeName == $RENDER_SETTINGS && python ("import maya.app.renderSetup.model.renderSettings as renderSettings; renderSettings.sceneHasRenderSettingsApplyOverrides()"))
	{
		$popUpMsg = (uiRes("m_unifiedRenderGlobalsWindow.kPopUpExportRenderSettings"));
		$hasApplyOverrides = 1;
	}
	else if ( python ("import maya.app.renderSetup.model.aovs as aovs; aovs.sceneHasAOVsApplyOverrides()") ) //&& $typeName == $AOVS
	{
		$popUpMsg = (uiRes("m_unifiedRenderGlobalsWindow.kPopUpExportAOVs"));
		$hasApplyOverrides = 1;
	}
	if ( $hasApplyOverrides )
	{
		string $title = $label;
		string $popUpAdditionalInfo = (uiRes("m_unifiedRenderGlobalsWindow.kPopUpAddInfo"));
		string $popUpFullMsg = $popUpMsg + "\n" + $popUpAdditionalInfo;
		string $confirm = (uiRes("m_unifiedRenderGlobalsWindow.kContinue"));
		string $cancel = (uiRes("m_unifiedRenderGlobalsWindow.kCancel"));
	
		string $response = `confirmDialog -title $title -message $popUpFullMsg
			-button $confirm -button $cancel -defaultButton $confirm
			-cancelButton $cancel -dismissString $cancel`;
		if ($response == $cancel)
		{
			return;
		}
	}

	if ($typeName == $RENDER_SETTINGS)
	{
		python ("import maya.app.renderSetup.views.renderSetupPreferences as rs_prefs ; rs_prefs.savePreset(\"" + $label + "\")");
	}
	else //$typeName == $AOVS
	{
		python ("import maya.app.renderSetup.views.renderSetupPreferences as rs_prefs ; rs_prefs.exportAOVs(\"" + $label + "\")");
	}
}

global proc UNIFIED_buildRenderGlobalsPresetsMenu()
{
	//
	// Description:
	//	This procedure builds the Presets menu in the render globals window.
	//
	setParent unifiedRenderGlobalsWindow;
	menu -edit -deleteAllItems presetsMenu;

    string $currentRenderer = currentRenderer();
	if ($currentRenderer == "mentalRay" &&
        size(`ls mentalrayGlobals`) == 0 )
	{
		miCreateDefaultNodes();
	}
    else if ($currentRenderer == "mayaVector" &&
             size(`ls vectorRenderGlobals`) == 0 )
    {
        vrCreateGlobalsNode();
    }
    // Check if the renderer specified any nodes to be saved
    // as presets.
    //
    string $globalsNodes[] =
        `renderer -q -globalsNodes $currentRenderer`;

    // If no nodes are specified, then no preset is provided.
    //
    if (size($globalsNodes) == 0)
    {
        return;
    }

	setParent -menu presetsMenu;

	string $globalRenderSetupPreset = (uiRes("m_unifiedRenderGlobalsWindow.kGlobalRenderSetupPreset2"));
	string $userRenderSetupPreset = (uiRes("m_unifiedRenderGlobalsWindow.kUserRenderSetupPreset2"));
	string $exportPresetLabel = (uiRes("m_unifiedRenderGlobalsWindow.kExportRenderSettings"));
	string $exportAOVs = (uiRes("m_unifiedRenderGlobalsWindow.kExportAOVs"));
	string $importAOVs = (uiRes("m_unifiedRenderGlobalsWindow.kImportAOVs"));
	string $importPresetLabel = (uiRes("m_unifiedRenderGlobalsWindow.kImportRenderSettings"));
	string $deletePresetLabel = (uiRes("m_unifiedRenderGlobalsWindow.kDeleteRenderSettings"));
	string $deleteUserPresetLabel = (uiRes("m_unifiedRenderGlobalsWindow.kDeleteUserRenderSettings"));
	string $defaultSettingsLabel = (uiRes("m_unifiedRenderGlobalsWindow.kDefaultSettings"));
	string $preferredPresetLabel = (uiRes("m_unifiedRenderGlobalsWindow.kSetPreferredRenderSettings"));
	
	global string $RENDER_SETTINGS;
	global string $AOVS;
	
	if (mayaHasRenderSetup())
	{
		int $AOVCallbacksAvailable = python ("import maya.app.renderSetup.model.rendererCallbacks as rendererCallbacks; not rendererCallbacks.getCallbacks(rendererCallbacks.CALLBACKS_TYPE_AOVS) is None");
	
		//------------------
		// Export Preset
		//------------------
		menuItem -label $exportPresetLabel
			-command ("confirmDialogExportCurrentValues \"" + 
						$exportPresetLabel + "\" \"" + 
						$RENDER_SETTINGS + "\"")
			URGSavePresetCtrl;

		//------------------
		// Export AOVs
		//------------------

		menuItem -en $AOVCallbacksAvailable 
			-label $exportAOVs
			-command ("confirmDialogExportCurrentValues \"" + 
						$exportAOVs + "\" \"" + 
						$AOVS + "\"");

		//------------------
		// Import AOVs
		//------------------

		menuItem -en $AOVCallbacksAvailable 
			-label $importAOVs
			-command ("python \"import maya.app.renderSetup.views.renderSetupWindow as rs_wind ; rs_wind._importAOVs(\\\""+$importAOVs+"\\\")\"");

		//------------------
		// Import Preset
		//------------------

		python "import maya.app.renderSetup.views.renderSetupPreferences as prefs";
		string $globalPresetArray[] = python ("prefs.getGlobalPresets(\"" + $currentRenderer + "\")");
		string $userPresetArray[] = python ("prefs.getUserPresets(\"" + $currentRenderer + "\")");

		menuItem -label $importPresetLabel -subMenu true URGLoadPresetCtrl;

		menuItem -label $defaultSettingsLabel
			-command ("python \"import maya.app.renderSetup.views.renderSetupPreferences as prefs ; prefs.setDefaultPreset()\"");

		menuItem -divider true;

		menuItem -label $globalRenderSetupPreset -subMenu true URGGlobalPresetCtrl;

		int $i;
		// Add a menu item for each available global preset.
		//
		for ($i = 0; $i < size($globalPresetArray); $i++)
		{
			menuItem -label $globalPresetArray[$i]
				-command ("python \"import maya.app.renderSetup.views.renderSetupPreferences as prefs ; prefs.loadGlobalPreset(\\\"" + $globalPresetArray[$i] + "\\\")\"");
		}
		setParent -menu ..; // from Global Preset menu

		menuItem -label $userRenderSetupPreset -subMenu true URGUserPresetCtrl;

		// Add a menu item for each available user preset.
		//
		for ($i = 0; $i < size($userPresetArray); $i++)
		{
			menuItem -label $userPresetArray[$i]
				-command ("python \"import maya.app.renderSetup.views.renderSetupPreferences as prefs ; prefs.loadUserPreset(\\\"" + $userPresetArray[$i] + "\\\")\"");
		}
		setParent -menu ..; // from User Preset menu

		setParent -menu ..; // from Load Preset menu

		//------------------
		// Delete Preset
		//------------------
		menuItem -label $deleteUserPresetLabel -subMenu true;

		if (size($userPresetArray) == 0)
		{
			menuItem -label (uiRes("m_unifiedRenderGlobalsWindow.kNoUserPresetsCurrentlyExist")) -enable false;
		}
		else
		{
			// Add a menu item for each available user preset.
			//
			for ($i = 0; $i < size($userPresetArray); $i++)
			{
				menuItem -label $userPresetArray[$i]
					-command ("python \"import maya.app.renderSetup.views.renderSetupPreferences as prefs ; prefs.deleteUserPreset(\\\"" + $userPresetArray[$i] + "\\\")\"");
			}
		}
		setParent -menu ..; // from Delete User Preset menu
		
		//------------------
		// Preferred Preset
		//------------------
		
		menuItem -label $preferredPresetLabel -subMenu true;

		int $preferredPresetExists = false;
		string $preferredPresetName;
		string $preferredRenderSetupPresetOptVar = (currentRenderer() + "PreferredRenderSetupPreset");
		string $preferredRenderSetupPresetTypeOptVar = (currentRenderer() + "PreferredRenderSetupPresetType");
		string $preferredRenderSetupPresetType = "";

		if (`optionVar -exists $preferredRenderSetupPresetOptVar`)
		{
		    if (`optionVar -exists $preferredRenderSetupPresetTypeOptVar `)
			{
			    $preferredRenderSetupPresetType = `optionVar -query $preferredRenderSetupPresetTypeOptVar`;
			}
			$preferredPresetExists = true;
			$preferredPresetName = `optionVar -query $preferredRenderSetupPresetOptVar`;
		}

		menuItem -label $defaultSettingsLabel -checkBox (!$preferredPresetExists)
			-command "removeRenderSetupPreferredPresets";

		menuItem -divider true;

		// Add a menu item to be able to set each available preset as your
		// preferred preset (to which render globals will be initialized
		// when you create a new file).
		//
		int $checkBoxValue;

		menuItem -label $globalRenderSetupPreset -subMenu true URGPreferredGlobalPresetCtrl;
		for ($i = 0; $i < size($globalPresetArray); $i++)
		{
			$checkBoxValue = false;
			if ($preferredPresetExists && $preferredRenderSetupPresetType == $globalRenderSetupPreset)
			{
				$checkBoxValue = ($globalPresetArray[$i] == $preferredPresetName);
			}
			menuItem -label $globalPresetArray[$i] -checkBox $checkBoxValue
				-command ("setPreferredRenderSetupPreset "+$globalPresetArray[$i] + " false");
		}
		setParent -menu ..; // from Global Preset menu

		menuItem -label $userRenderSetupPreset -subMenu true URGPreferredUserPresetCtrl;
		for ($i = 0; $i < size($userPresetArray); $i++)
		{
			$checkBoxValue = false;
			if ($preferredPresetExists && $preferredRenderSetupPresetType == $userRenderSetupPreset)
			{
				$checkBoxValue = ($userPresetArray[$i] == $preferredPresetName);
			}
			menuItem -label $userPresetArray[$i] -checkBox $checkBoxValue
				-command ("setPreferredRenderSetupPreset "+$userPresetArray[$i] + " true");
		}
		setParent -menu ..; // from User Preset menu

		setParent -menu ..; // from Set Preferred Preset menu
	}
	else
	{
		//------------------
		// Export Preset
		//------------------

		menuItem -label $exportPresetLabel
			-command "saveNodePresetDialog(`renderer -q -globalsNodes (currentRenderer())`, getRenderSettingPresetArgs((currentRenderer())))"
			URGSavePresetCtrl;

		//------------------
		// Import Preset
		//------------------

		string $presetArray[];
		$presetArray = `nodePreset -list $globalsNodes[0]`;
		
		menuItem -label $importPresetLabel -subMenu true URGLoadPresetCtrl;

		menuItem -label $defaultSettingsLabel -command "unifiedRenderGlobalsRevertToDefault";

		menuItem -divider true;

		// Add a menu item for each available preset.
		//
		int $i;
		for ($i = 0; $i < size($presetArray); $i++)
		{
			menuItem -label $presetArray[$i]
				-command ("loadNodePresets \"" + $presetArray[$i] + "\"" );
		}
		setParent -menu ..; // from Load Preset menu


		//------------------
		// Delete Preset
		//------------------

		menuItem -label $deletePresetLabel -subMenu true;

		if (size($presetArray) == 0)
		{
			menuItem -label (uiRes("m_unifiedRenderGlobalsWindow.kNoPresetsCurrentlyExist")) -enable false;
		}
		else
		{
			string $commaNodes;
			for ($node in $globalsNodes) {
				// Enclose the node in quotes and comma separate them.
				$commaNodes += "\"" + $node + "\", ";
			}

			// Add a menu item to be able to delete each available preset.
			//
			for ($i = 0; $i < size($presetArray); $i++)
			{
				menuItem -label $presetArray[$i]
					-command ( "nodePresetConfirmDeleteDialog { "
							+ $commaNodes + "\"" + $presetArray[$i] + "\" }" );
			}
		}
		setParent -menu ..; // from Delete Preset menu

		
		//------------------
		// Preferred Preset
		//------------------
		
		menuItem -label $preferredPresetLabel -subMenu true;

		int $preferredPresetExists = false;
		string $preferredPresetName;
		string $preferredPresetOptVar = (currentRenderer() + $globalsNodes[0] + "PreferredPreset");

		if (`optionVar -exists $preferredPresetOptVar`)
		{
			$preferredPresetExists = true;
			$preferredPresetName = `optionVar -query $preferredPresetOptVar`;
		}

		menuItem -label $defaultSettingsLabel -checkBox (!$preferredPresetExists)
			-command "removePreferedPresets";

		menuItem -divider true;

		// Add a menu item to be able to set each available preset as your
		// preferred preset (to which render globals will be initialized
		// when you create a new file).
		//
		int $checkBoxValue;

		for ($i = 0; $i < size($presetArray); $i++)
		{
			$checkBoxValue = false;
			if ($preferredPresetExists)
			{
				$checkBoxValue = ($presetArray[$i] == $preferredPresetName);
			}
			menuItem -label $presetArray[$i] -checkBox $checkBoxValue
				-command ("setPreferedPreset "+$presetArray[$i]);
		}
		setParent -menu ..; // from Set Preferred Preset menu
	}
}

global proc initRenderSettingsWindow()
{
	// Make sure that the current renderer is assigned to a renderer that exists on startup.
	// Fixes: MAYA-70412.
	//
	string $cr = currentRenderer();
	if ("" == $cr || !`renderer -exists $cr`)
	{
		string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
		setCurrentRenderer $renderers[0];
	}

	//	Create a menu bar layout for the Render Settings panel.
	//
	menuBarLayout;
	
	// Set up the menus
	//
	menu -label (uiRes("m_unifiedRenderGlobalsWindow.kEdit"));
	menuItem -label (uiRes("m_unifiedRenderGlobalsWindow.kChangeProjectImage"))
		-c "ProjectWindow";

	menu -label (uiRes("m_unifiedRenderGlobalsWindow.kPresets"))
		-postMenuCommand "UNIFIED_buildRenderGlobalsPresetsMenu"
		presetsMenu;

	//	Adds support for the Context Sensitive Help Menu.
	//
	addContextHelpProc "unifiedRenderGlobalsWindow" "UNIFIED_buildRenderGlobalsContextHelpItems";

	doHelpMenu "unifiedRenderGlobalsWindow" "unifiedRenderGlobalsWindow";

	formLayout rgMainForm;

	//--------------------------------------------------------------
	// Create a frame containing:
	// - A pulldown menu for switching between render layers;
	// - A pulldown menu for switching between renderers;
	// - The optional rendering logo on a button.
	//--------------------------------------------------------------
	frameLayout -labelVisible false -cll false -cl false
		rendererPlusLayerLayout;

	string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
	string $rendererUIName = "";
	$selectForm = `formLayout`;

	$selectLayer = `rowLayout -numberOfColumns 2`;

	text -label (uiRes("m_unifiedRenderGlobalsWindow.kCurrentLayer"));
	optionMenu
		-annotation (uiRes("m_unifiedRenderGlobalsWindow.kCurrentLayerAnn"))
		-cc "updateCurrentRenderLayerSel"
		unifiedRenderGlobalsRenderLayerOptionMenu;

	setParent ..; // from rowLayout

	$selectRenderer = `rowLayout -numberOfColumns 2`;

	text -label (uiRes("m_unifiedRenderGlobalsWindow.kRenderUsing")) unifiedRenderGlobalsRendererSelOptionMenuText;
	optionMenu
			-annotation (uiRes("m_unifiedRenderGlobalsWindow.kSelectRenderer"))
			-cc "updateCurrentRendererSel(\"unifiedRenderGlobalsRendererSelOptionMenu\")"
			unifiedRenderGlobalsRendererSelOptionMenu;

	connectControl unifiedRenderGlobalsRendererSelOptionMenuText defaultRenderGlobals.currentRenderer;

	// If we cannot find the default renderer (the corresponding
	// plug-in may not be loaded, default the menu to the first
	// available renderer.
	int $selectedItem = 1;
	for ($i = 0; $i < size($renderers); $i += 1)
	{
		$rendererUIName = `renderer -query -rendererUIName $renderers[$i]`;
		menuItem -l $rendererUIName
				 -enableCommandRepeat false
				 ("unifiedRenderGlobalsRendererSelOptionMenuItem" +$i);

		// Check if this renderer is the same as currentRenderer.
		//
		if ($renderers[$i] == currentRenderer())
		{
			$selectedItem = $i + 1;
		}
	}

	// Set the renderer to the the current renderer.
	//
	optionMenu -edit
		-select $selectedItem unifiedRenderGlobalsRendererSelOptionMenu;

	setParent ..;  // from rowLayout

	// Create the symbol button for the renderer logo.
	// The image, visibility state, and callback for the button
	// are set in updateCurrentRendererLogo().
	//
	symbolButton -visible false unifiedRenderGlobalsRendererLogoPicture;
	updateCurrentRendererLogo();

	// Set up the form such that the logo is right justified
	// in the frame.
	//
	formLayout -edit
		-attachForm $selectLayer "top" 2
		-attachForm $selectLayer "left" 2
		-attachNone $selectLayer "right"
		-attachNone $selectLayer "bottom"

		-attachControl $selectRenderer "top" 4 $selectLayer

		-attachForm $selectRenderer "left" 2
		-attachNone $selectRenderer "right"
		-attachForm $selectRenderer "bottom" 2

		-attachForm unifiedRenderGlobalsRendererLogoPicture "top" 2
		-attachNone unifiedRenderGlobalsRendererLogoPicture "left"
		-attachForm unifiedRenderGlobalsRendererLogoPicture "right" 2
		-attachForm unifiedRenderGlobalsRendererLogoPicture "bottom" 2
		$selectForm;
	setParent ..; // from formLayout

	setParent ..;  // from rendererPlusLayerLayout;

	//--------------------------------------------------------------
	// Tabs
	//--------------------------------------------------------------
	formLayout tabForm;

	// Define a template for scrollLayout which will be used when
	// creating the scrollLayouts inside of each of the following tabs.
	//
	if (!`uiTemplate -exists renderGlobalsTemplate`)
	{
		uiTemplate renderGlobalsTemplate;

		scrollLayout
				-defineTemplate renderGlobalsTemplate
				-horizontalScrollBarThickness 0
				-verticalScrollBarThickness 16;
	}

	setParent ..; // from tabForm

	//--------------------------------------------------------------
	// Button area starts
	//--------------------------------------------------------------

	button -label (uiRes("m_unifiedRenderGlobalsWindow.kClose"))
		-h 26
		-c "workspaceControl -e -vis 0 unifiedRenderGlobalsWindow"
		rgCloseBtn;

	setParent ..;  // from rgMainForm

	// Fix up the layout

	formLayout -edit

		-af rendererPlusLayerLayout "top" 0
		-af rendererPlusLayerLayout "left" 0
		-af rendererPlusLayerLayout "right" 0
		-an rendererPlusLayerLayout "bottom"

		-ac tabForm top 5 rendererPlusLayerLayout
		-af tabForm left 0
		-af tabForm right 0
		-ac tabForm bottom 5 rgCloseBtn

		-an rgCloseBtn "top"
		-af rgCloseBtn "bottom" 5
		-af rgCloseBtn "left" 5
		-af rgCloseBtn "right" 5
		rgMainForm;

	setUITemplate -popTemplate ;

	// register the procedure responsible for updating all renderer
	// related UI created in this script
	//
	registerUpdateRendererUIProc("updateUnifiedRenderGlobalsWindowSpecifiedUI");
	scriptJob -event SceneOpened unifiedRenderGlobalsWindowSceneOpenedCallback
		-parent unifiedRenderGlobalsWindow;
	scriptJob -event renderLayerManagerChange updateUnifiedRenderGlobalsWindowSpecifiedUI
		-parent unifiedRenderGlobalsWindow;
	scriptJob -event renderLayerChange updateUnifiedRenderGlobalsWindowSpecifiedUI
		-parent unifiedRenderGlobalsWindow;

	updateUnifiedRenderGlobalsWindowSpecifiedUI;
	
	// Display the tabs of the current renderer.
    //
    updateCurrentRendererTabs();
	
	// Send a notification that the Render Settings have been built.
	string $renderer = currentRenderer();
	callbacks -executeCallbacks -hook "renderSettingsBuilt" $renderer;
}

global proc createRenderSettingsWindow()
//
//  Procedure Name:
//      createRenderSettingsWindow
//
//  Description:
//      This procedure only builds the Render Settings UI WITHOUT showing it.
//      If you want to show the window and/or update tabs use unifiedRenderGlobalsWindow instead.
//      If you only want to create the UI to add or delete tabs use this procedure.  
{
    if (!`workspaceControl -exists unifiedRenderGlobalsWindow`) {
        // Create the workspace control
        //
		workspaceControl -label (localizedUIMisc("Render Settings"))
            -initialWidth 456 -initialHeight 670
			-checksPlugins true
            -retain true
			-uiScript "initRenderSettingsWindow()"
			-loadImmediately true
            unifiedRenderGlobalsWindow;
	}

}

global proc unifiedRenderGlobalsWindow ()
//
//  Procedure Name:
//      unifiedRenderGlobalsWindow
//
//  Description:
//		This procedure builds and show the UI for the Render Settings window 
//		The update* procedures make sure that the values are valid.
//		And the change* procedures do the editing of the values.
//
{
	// If the window exists already, just show it.
	//
	if (`workspaceControl -exists unifiedRenderGlobalsWindow`) {
		workspaceControl -e -restore unifiedRenderGlobalsWindow;
		updateCurrentRendererTabs();
		return;
	}
    
    createRenderSettingsWindow();

    //--------------------------------------------------------------
    // Show window
    //--------------------------------------------------------------
    showWindow unifiedRenderGlobalsWindow;
}

//==================================================================
// Update UI when rendererChanged.
//==================================================================
global proc updateUnifiedRenderGlobalsWindowSpecifiedUI()
{
    setParent unifiedRenderGlobalsWindow;

	// Change the optionMenuGrp for switching between layers.
	//
	updateRenderLayerOptionMenu();

    // Change the optionMenuGrp for switching between renderers.
    //

    int $i;
	string $renderers[] = `renderer -query -namesOfAvailableRenderers`;

	// Check for any updates in the renderer list
	//
	int $numItems =
        `optionMenu
			-query
			-numberOfItems
			unifiedRenderGlobalsRendererSelOptionMenu`;

	// Make sure all the renderers are being shown in the option menu.
	//
	if($numItems != size($renderers))
	{
		setParent -menu unifiedRenderGlobalsRendererSelOptionMenu;

		string $menuItemNames[] =
			`optionMenu
				-query
				-itemListLong
				unifiedRenderGlobalsRendererSelOptionMenu`;

		// Remove all the menuItems and create new ones to reflect the
		// renderers currently available
		//
		for ($i = 0; $i < size($menuItemNames); $i++)
		{
			deleteUI $menuItemNames[$i];
		}

		for ($i = 0; $i < size($renderers); $i++)
		{
            $rendererUIName = `renderer -query -rendererUIName $renderers[$i]`;
			menuItem
				-label $rendererUIName
				-enableCommandRepeat false
				("unifiedRenderGlobalsRendererSelOptionMenuItem" + $i);
		}

		setParent ..;
	}

	// Update the Renderer selection option box to reflect current
    // renderer.
	//

	for ($i = 0; $i < size($renderers); $i++)
	{
		if($renderers[$i] == currentRenderer())
		{
			optionMenu
				-edit
				-select ($i+1)
				unifiedRenderGlobalsRendererSelOptionMenu;
		}
	}

	// Update the visibility of the Renderer logo picture
	// depending on the current renderer.
	//
	updateCurrentRendererLogo();

    updateCurrentRendererTabs();

    // image format section in the common tab is renderer specific.
    updateMayaImageFormatControl();

    // Update the current render layer information in
    // the render setting window's title.
    // If the master layer is the only render layer, then do not
    // show layer name in the window title.
    // If there exists any non master render layer, then show
    // the current render layer's name.
    //
    string $newTitle = localizedUIMisc("Render Settings");
    string $layerName = currentRenderLayerLabel();

    if ($layerName != "")
    {
        $newTitle = (uiRes("m_unifiedRenderGlobalsWindow.kNewRenderSettings"));
        $newTitle = `format -s $layerName $newTitle`;
    }

    workspaceControl -edit -label $newTitle unifiedRenderGlobalsWindow;

}

//==================================================================
// Other Tab handler
//==================================================================
// Description:
// Returns:  This procedure returns the name of the tabLayout for
//           the specified renderer.
//
global proc string rendererTabLayoutName(string $renderer)
{
    string $tabLayoutName = $renderer+"TabLayout";
    return $tabLayoutName;
}

// Description:
// Returns:  This procedure returns the name of a tab for the
//           specified renderer.  The name of the tab consists
//           of three parts
//              . the renderer's name ("masterLayer" will be
//				  used if we're displaying all renderer tabs),
//              . the tabLabel with white spaces removed,
//              . the ending "Tab".
//
global proc string rendererTabName(string $renderer, string $tabLabel)
{
    // The tabName is the tabLabel with the white space removed
    // and the word "Tab" added to the end.
    //
    string $tabName = `substituteAllString $tabLabel " " ""`;
    $tabName = `substituteAllString $tabName "." ""`;
	if( isDisplayingAllRendererTabs() ){
		global string $gMasterLayerRendererName;
		$tabName = $gMasterLayerRendererName+$tabName+"Tab";
	}else{
	    $tabName = $renderer+$tabName+"Tab";
	}
    return $tabName;
}

// Description:
// Returns: This procedure returns the name of the control with
//          the $renderer name as a prefix.
//
global proc string rendererControlName(string $renderer, string $control)
{
    string $controlName = $renderer + $control;
    return $controlName;
}

// Description:
//	Calls "createProc" routine(s) to fill the selected tab
//	in the given tabLayout.
global proc fillSelectedTabForTabLayout(string $tabLayoutName)
{
	int $selectedTab = `tabLayout -q -sti $tabLayoutName`;
	string $tabNames[] = `tabLayout -q -ca $tabLayoutName`;

	// Check if the tab content was already created
	string $parentForm = $tabNames[ $selectedTab-1 ];
	string $tabChildren[] = `formLayout -q -ca $parentForm`;
	if (size($tabChildren) != 0)
		return;

	string $createProcs[] = {};
	if ( isDisplayingAllRendererTabs() )
	{
		// Tabs for all rendererers are displayed.
		// Make list of create procs that corresponds to the tabs
		// List should look something like this:
		//	{ "createMayaSoftwareCommonGlobalsTab", "createMayaSoftwareGlobalsTab",
		//	"createMayaHardwareGlobalsTab ", "createVectorGlobalsTab ",
		//	"createMayaRenderPassTab",
		//	"createMentalRayFeaturesTab", "createMentalRayQualityTab",
		//	"createMentalRayIndirectLightingTab", "createMentalRayOptionsTab" };
		string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
		for ($renderer in $renderers)
		{
			string $rendererProcs[] = `renderer -query -globalsTabCreateProcNames $renderer`;
			int $numProcs = `size $rendererProcs`;
			appendStringArray($createProcs, $rendererProcs, $numProcs);
		}
		$createProcs = stringArrayRemoveDuplicates( $createProcs );
	}
	else
	{
		string $renderer = currentRenderer();

		// Get the createProcs for the current renderer
		$createProcs = `renderer -query -globalsTabCreateProcNames $renderer`;
	}

	// Call the create proc for the selected tab
	string $createProc = $createProcs[ $selectedTab-1 ];
	$parentForm = $tabNames[ $selectedTab-1 ];
	if ($createProc == "")
		return;

	setParent $parentForm;
	if (!(`match "MentalRay" $createProc` == "MentalRay") )
	{
		// If it is not a mental ray tab, just eval this proc
		eval($createProc);
	}
	else
	{
		// For mental ray create procs, eval all mental ray procs
		// because there are dependencies between the tabs
		string $tempProc;
		int $tabNum = 0;
		for ($tempProc in $createProcs) {

			string $tabForm = $tabNames[$tabNum];
			if (`formLayout -exists $tabForm`)
				setParent $tabForm;
			if (`match "MentalRay" $tempProc` == "MentalRay") {
				eval($tempProc);
			}
			$tabNum++;
		}
	}
}

// Description:
//		This procedure is set up as the "preSelectCommand" for the tabs
//		when we're displaying all renderer tabs
//		it creates the content of the selected tab - this is to make the window
//		more efficent in use of memory (298476)
global proc fillSelectedTabForMasterLayerTabLayout()
{
	global string $gMasterLayerRendererName;
	string $tabLayoutName = rendererTabLayoutName($gMasterLayerRendererName);
	fillSelectedTabForTabLayout( $tabLayoutName );

}

// Description:
//		This procedure is set up as the "preSelectCommand" for the tabs
//		when an individual renderer is in use.
//		Creates the content of the selected tab
//		- this is to make the window more efficent in use of memory (298476)
global proc fillSelectedTabForCurrentRenderer()
{
	string $renderer = currentRenderer();
	string $tabLayoutName = rendererTabLayoutName($renderer);

	fillSelectedTabForTabLayout( $tabLayoutName );
}

// Description: This procedure is called to return the name of the
//              rendererTabLayout.  If such tabLayout does not exist
//              yet for the specified renderer, then we initialize
//              the tabLayout for the specified renderer.
//
//              The initialization involves:
//                  . create the tabLayout
//                  . initialize the common tab.
//
global proc string getRendererTabLayout(string $renderer)
{
    setParent tabForm;

    string $tabLayoutName = rendererTabLayoutName($renderer);

    if (`tabLayout -exists $tabLayoutName`)
    {
        return $tabLayoutName;
    }

    // Create the tab layout.
    // The tabLayout is only "manage"d if the specified renderer
    // is associated with the current renderer.
    //
    int $isCurrentRenderer = false;

	if( isDisplayingAllRendererTabs() )
	{
		// Create the tabLayout if it doesn't exist
		tabLayout	-manage true
					-tabsVisible true
					-width 1
					-preSelectCommand "fillSelectedTabForMasterLayerTabLayout"
					$tabLayoutName;
	}
	else
	{
		if( $renderer == currentRenderer() )
		{
			$isCurrentRenderer = true;
		}
		tabLayout	-manage $isCurrentRenderer
					-tabsVisible true
					-width 1
					-preSelectCommand "fillSelectedTabForCurrentRenderer"
					$tabLayoutName;
    }

    setParent ..; // from tabLayout

    formLayout
            -edit
            -af $tabLayoutName top 0
            -af $tabLayoutName left 0
            -af $tabLayoutName right 0
            -af $tabLayoutName bottom 0
            tabForm;

    return $tabLayoutName;
}

proc string renderSettingsTabLabel_melToUI (string $mel)
{
	// The arguments passed inside this procedure should not
	// be localized. This procedure uses the first string
	// argument that is passed with the "-addGlobalsTab"
	// flag in the "renderer" command.
	//
	string $result = $mel;

	if($mel == "Common"){
		$result = (uiRes("m_unifiedRenderGlobalsWindow.kCommon"));
	}
	else if($mel == "Passes"){
		$result = (uiRes("m_unifiedRenderGlobalsWindow.kPassesTab"));
	}
	else if($mel == "Maya Software"){
		$result = (uiRes("m_unifiedRenderGlobalsWindow.kMayaSoftware"));
	}
	else if($mel == "Maya Hardware"){
		$result = (uiRes("m_unifiedRenderGlobalsWindow.kMayaHardware"));
	}
	else if($mel == "Maya Vector"){
		$result = (uiRes("m_unifiedRenderGlobalsWindow.kMayaVector"));
	}
	else if($mel == "Features"){
		$result = (uiRes("m_unifiedRenderGlobalsWindow.kFeatures"));
	}
	else if($mel == "Quality"){
		$result = (uiRes("m_unifiedRenderGlobalsWindow.kQuality"));
	}
	else if($mel == "Indirect Lighting"){
		$result = (uiRes("m_unifiedRenderGlobalsWindow.kIndirectLighting"));
	}
	else if($mel == "Options"){
		$result = (uiRes("m_unifiedRenderGlobalsWindow.kOptions"));
	}
	else{
		uiToMelMsg( "renderSettingsTabLabel_melToUI", $mel, 0 );
	}

	return $result;
}


// Description: This procedure allows a renderer to add one tab
//              to the unified render globals window
//              and create the content in the tab using a procedure.
//
// Input:
//              The "rendererName" is the name of the renderer.
//              The "tabName" is the name of the tab.
//              The "createProcName" is the name of the procedure
//              used to create the content of the tab.
//
global proc addOneTabToGlobalsWindow(
    string $renderer, string $tabLabel, string $createProc)
{
    // Check to see if the unified render globals window existed.
    // If it does not exist, then we don't need to add any tab yet.
    //

    if (!`workspaceControl -exists unifiedRenderGlobalsWindow`)
    {
        catch(error (uiRes("m_unifiedRenderGlobalsWindow.kCannotAddTabs")));
        return;
    }

    // MAYA-87353: When Maya is started up with the render settings window present, the tabForm is not immediately available.
    // This will prevent the errors associated with the tabForm not being present at that time.
	if (!`formLayout -q -exists tabForm`) return;
	
	int $displayAllTabs = isDisplayingAllRendererTabs();
	if( !$displayAllTabs )
	{
		// If the current renderer the renderer is not this
		// renderer, then don't add the tab yet.
		//
		if( currentRenderer() != $renderer )
		{
			return;
		}
    }

    setParent unifiedRenderGlobalsWindow;

    // Hide the tabForm while updating.
    //
    int $tabFormManagedStatus = `formLayout -q -manage tabForm`;
    formLayout -edit -manage false tabForm;
    setParent tabForm;

	// Set the correct tabLayout parent.
	//
	string $tabLayoutName;
	if( $displayAllTabs ){
		global string $gMasterLayerRendererName;
		$tabLayoutName = getRendererTabLayout($gMasterLayerRendererName);
	}else{
		$tabLayoutName = getRendererTabLayout($renderer);
	}
	setParent $tabLayoutName;

    // The tabName is the tabLabel with the white space removed
    // and the word "Tab" added to the end.
	// "masterLayer" will act as the renderer name if the tab
	// is in the master layer.
    //
    string $tabName = rendererTabName($renderer, $tabLabel);

    // if the tab-control does not exist, define it and add it
    // to the tabLayout
    //
    if (!`layout -exists $tabName`)
    {
        setUITemplate -pushTemplate renderGlobalsTemplate;
        setUITemplate -pushTemplate attributeEditorTemplate;

	    // Define the tab
	    //
		formLayout $tabName;

	    // get the content of the tab from the createTabProc
	    //

		// Most create procs are now deferred till the tab is selected
		// These two are the default tabs, so we don't defer them
		if (($createProc == "createMayaSoftwareCommonGlobalsTab")
			|| ($createProc == "createMayaSoftwareGlobalsTab"))

		{
			eval($createProc);
		}
		else
		{
			callbacks -executeCallbacks -hook "rendererAddOneTabToGlobalsWindowCreateProc" $createProc;
		}

		// These end off the layouts of the information in the Tab
	    //
	    setParent ..;

        setUITemplate -popTemplate;
        setUITemplate -popTemplate;

		// Add the tab to the tabLayout
		//
		tabLayout
			-edit
			-tabLabel $tabName `renderSettingsTabLabel_melToUI $tabLabel`
			$tabLayoutName;
    }

    // Restore the old manage status for the tabForm.
    //
    formLayout -edit -manage $tabFormManagedStatus tabForm;
}


// Description:
//		Create the renderer tabs for the master layer.
//		This will contain the tabs for ALL available renderers.
//
global proc addMasterLayerTabsToGlobalsWindow()
{

    // Check to see if the unified render globals window existed.
    // If it does not exist, then we don't need to add any tab yet.
    //
    if (!`workspaceControl -exists unifiedRenderGlobalsWindow`)
    {
        catch(error (uiRes("m_unifiedRenderGlobalsWindow.kCannotAddTabs")) );
        return;
    }

    setParent unifiedRenderGlobalsWindow;

    // Hide the tabForm while updating.
    //
    int $tabFormManagedStatus = `formLayout -q -manage tabForm`;
    formLayout -edit -manage false tabForm;
    setParent tabForm;

	// Get the tab layout name. Will create the layout if it doesn't
	// already exist.
	//
    global string $gMasterLayerRendererName;
    string $tabLayoutName = getRendererTabLayout($gMasterLayerRendererName);
    setParent $tabLayoutName;

    // For each renderer, recreate its tabs.
    //
	int $i, $j, $commonTabCreated=false;
	string $renderers[] = `renderer -query -namesOfAvailableRenderers`;

	for ($i = 0; $i < size($renderers); $i++){
		// Get the tabLabels and createProcNames.
		string $tabLabels[] = `renderer -query -globalsTabLabels $renderers[$i]`;
		string $createProcNames[] = `renderer -query -globalsTabCreateProcNames $renderers[$i]`;

		for ($j = 0; $j < size($tabLabels); $j++)
		{
			// Check if the tab already exists
			//
			if( ("createMayaSoftwareCommonGlobalsTab" == $createProcNames[$j]) ){
				if( $commonTabCreated == false ){
					$commonTabCreated = true;
				}else{ // $commonTabCreated == true
					// Common tab already exists. Don't create it.
					continue;
				}
			}

			addOneTabToGlobalsWindow(
				$renderers[$i],
				$tabLabels[$j],
				$createProcNames[$j]);
		}
	}

    setParent ..;

    // Restore the old manage status for the tabForm.
    //
    formLayout -edit -manage $tabFormManagedStatus tabForm;
}


// Description: This procedure lets the specified renderer to
//              add all its tabs to the unified render globals window.
//
global proc addRendererTabsToGlobalsWindow(string $renderer)
{
	// Check to see if the unified render globals window existed.
    // If it does not exist, then we don't need to add any tab yet.
    //
    if (!`workspaceControl -exists unifiedRenderGlobalsWindow`)
    {
        catch(error (uiRes("m_unifiedRenderGlobalsWindow.kCannotAddTabs")) );
        return;
    }
	
	// This will prevent the errors associated with the tabForm not being present at that time.
	if (!`formLayout -q -exists tabForm`) return;

	int $displayAllTabs = isDisplayingAllRendererTabs();
	if( !$displayAllTabs )
	{
		// If the current renderer the renderer is not this
		// renderer, then don't add the tab yet.
		//
		if( currentRenderer() != $renderer )
		{
			return;
		}
    }

    setParent unifiedRenderGlobalsWindow;

    // Hide the tabForm while updating.
    //
    int $tabFormManagedStatus = `formLayout -q -manage tabForm`;
    formLayout -edit -manage false tabForm;
    setParent tabForm;

	// Get the tab layout name. Will create the layout if it doesn't
	// already exist.
	//
	string $tabLayoutName;
	if( $displayAllTabs ){
		global string $gMasterLayerRendererName;
		$tabLayoutName = getRendererTabLayout($gMasterLayerRendererName);
	}else{
		$tabLayoutName = getRendererTabLayout($renderer);
	}
	setParent $tabLayoutName;

    // Get the tabLabels and createProcNames.
    //
    string $tabLabels[] = `renderer -query -globalsTabLabels $renderer`;
    string $createProcNames[] =
        `renderer -query -globalsTabCreateProcNames $renderer`;

    int $i;
    for ($i = 0; $i < size($tabLabels); $i++)
    {
		addOneTabToGlobalsWindow(
			$renderer,
			$tabLabels[$i],
			$createProcNames[$i]);
	}

    setParent ..;

    // Restore the old manage status for the tabForm.
    //
    formLayout -edit -manage $tabFormManagedStatus tabForm;
}

// Description: Set the current tab in the render globals window from
//              the given label. If tab does not exist for the current
//              renderer then do nothing
//
global proc setCurrentTabInRenderGlobalsWindow(string $tabLabel)
{
	// get tab layout name
	string $currentRenderer = currentRenderer();
	int $displayAllTabs = isDisplayingAllRendererTabs();
	string $tabLayoutName;
	if ($displayAllTabs) {
		global string $gMasterLayerRendererName;
		$tabLayoutName = rendererTabLayoutName($gMasterLayerRendererName);
	} else {
		$tabLayoutName = rendererTabLayoutName($currentRenderer);
	}

	if (`tabLayout -exists $tabLayoutName`) {
		setParent $tabLayoutName;
		// get name of tab and set to current if it exists in the
		// current tab layout
		string $tabName = rendererTabName($currentRenderer, $tabLabel);
		string $allTabs[] = `layout -q -childArray $tabLayoutName`;
		if (stringArrayContains($tabName, $allTabs)) {
			tabLayout -edit
				-selectTab $tabName
				$tabLayoutName;
		}
	}
}


//==================================================================
// Misc
//==================================================================

//==================================================================
//
// Add Context Sensitive Help
//
//==================================================================

global proc UNIFIED_buildRenderGlobalsContextHelpItems(
	string $nameRoot,
	string $menuParent)
{
	menuItem -label (uiRes("m_unifiedRenderGlobalsWindow.kHelpOnRenderSettings"))
		-enableCommandRepeat false
		-command "showHelp RenderGlobals";
}

// Description:
// This procedure removes the tabs in the unified render globals
// window for one renderer.
//
proc removeRendererTabsFromGlobalsWindow(string $renderer)
{
    // Check to see if the unified render globals window existed.
    // If it does not exist, then we don't need to remove any tab.
    //
    if (!`workspaceControl -exists unifiedRenderGlobalsWindow`)
    {
        return;
    }

    setParent unifiedRenderGlobalsWindow;
    setParent tabForm;

    string $tabLayoutName = getRendererTabLayout($renderer);

    // If this renderer's tabLayout exists, remove it.
    //
    if (`tabLayout -exists $tabLayoutName`)
    {
        deleteUI $tabLayoutName;
    }
}

// Description: This procedure refreshes the unified render
//      globals window when a different scene is opened.
//
global proc unifiedRenderGlobalsWindowSceneOpenedCallback()
{
    setParent tabForm;
    string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
    int $i;
    // For each renderer, delete its tabs.
    //
    for ($i = 0; $i < size($renderers); $i++)
    {
        removeRendererTabsFromGlobalsWindow($renderers[$i]);
    }

    // For each renderer, recreate its tabs.
    //
    for ($i = 0; $i < size($renderers); $i++)
    {
        addRendererTabsToGlobalsWindow($renderers[$i]);
    }

	// Delete the master layer tabs
	//
	global string $gMasterLayerRendererName;
	string $tabLayoutName = rendererTabLayoutName($gMasterLayerRendererName);
    if( `tabLayout -exists $tabLayoutName` )
    {
        deleteUI $tabLayoutName;
    }

	// Recreate the master layer tabs if we are displaying it
	//
	if( isDisplayingAllRendererTabs() )
	{
		addMasterLayerTabsToGlobalsWindow();
   	}
}

